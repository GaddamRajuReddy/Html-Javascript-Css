Javascript in scripting langulage used to develop dynamic web applications

//commnet can be write like this in js or /* * /

//to get/set data of refrence of html elemnt by id class, tag
//get
document.getElementsById("example");
document.getElementsByClassName("example");
document.getElementsByName("fname");
document.getElementsByTagName("LI");

//set
document.getElementById("demo").innerHTML = "<br>Hello JavaScript";
document.getElementsByClassName("demo").style.display = "none";
document.getElementById("demo").innerText = "text";

JavaScript identifiers (names) must begin with:
1. A letter (A-Z or a-z)
2. A dollar sign ($)
3. Or an underscore (_)

//variabls
var cust="a" , const cust=5 , let cust=false;
A var variable can be redeclared and updated.and scope in within funtion scope
A let variable be be updated but not redeclared.and scope in within block  scoped
A const value not chnagable, value must assigned when decalred, it’s block-scoped,

Variables created without a declaration keyword (var, let, or const) are always global, even if they are created inside a function.
Global variables live until the page is discarded, like when you navigate to another page or close the window.
Local variables have short lives. They are created when the function is invoked, and deleted when the function is finished.


let points = 50;
let winner = false;
if(points > 40) {
  let winner = true;
}
console.log(winner); // false

var points = 50;
var winner = false;
if(points > 40) {
  var winner = true;
}
console.log(winner); // true



var carName;			//undefined

var carName = "Volvo";		// redeclaring posible for var 
var carName;			// it can't loose its value 

var x = "5" + 2 + 3;		//523

var x = 2 + 3 + "5";		//55

var x = "100";
var y = "10";
var z = x - y;			//90

var x = 100 / "Apple";
isNaN(x); 			//returns True

var x = NaN;
var y = "5";
var z = x + y;			//NaN5

var x = NaN;
var y = 5;
var z = x + y;         		// z will be NaN


var x = 10;			//assignment operators
x += 5;


= is used for assigning values to a variable in JavaScript.
== is used for comparison between two variables irrespective of the datatype of variable.
=== is used for comparision between two variables and check datatype and compare two values.

typeof null  			//the data type of null is an object.
typeof undefined		//the data type of undefined is an undefined.
typeof "John"                 	// Returns "string"
typeof 3.14                   	// Returns "number"
typeof NaN                    	// Returns "number"
typeof false                  	// Returns "boolean"
typeof [1,2,3,4]              	// Returns "object"
typeof {name:'John', age:34}  	// Returns "object"
typeof new Date()             	// Returns "object"
typeof function () {}         	// Returns "function"
typeof myCar                  	// Returns "undefined" *
typeof null                   	// Returns "object"


undefined and null are equal in value but different in data type: both defination is a variable without value is undefined/null


premitives data types: 
string
number
boolean
undefined
null

objects:
array
object
function

var y = new Number(123);
var y = new String("John");
var x = new Array("Saab", "Volvo", "BMW");
var d = new Date();
var y = new Boolean(false);


Number Methods:

toString()			//returns a number as a string.
valueOf() 			//returns a number as a number.
toFixed(2)			//returns a string, with the number written with a specified number of decimals:
toPrecision() 	//returns a string, with a number written with a specified length:

Converting Variables to Numbers:
Number()			  //Returns a number, converted from its argument.spacess not allowed

parseFloat()		//Parses its argument and returns a floating point number, spacess allowed and first no taken

parseInt()			//Parses its argument and returns an integer,spacess allowed and first no taken
parseInt("10.33");      	// returns 10
parseInt("10 20 30");   	// returns 10



object:  

var person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
//read data from objct
person.firstname	o/p- John
person["firstname"]	o/p- John

//add extra properties to object
person["country"]="india";
person.city="hyd";

//looping object or to diaply keys and values in object
for (var key of Object.keys(person)) {
    console.log(key + " -> " + person[key])    o/p- firstname -> John
}

//looping object or to diaply keys and values in object
for (let key in person) {
  console.log(key);          //object kyes
  console.log(person[key]);  //object values
}

//looping object or to diaply keys and values in object
Object.keys(person).forEach(function(key) {
    console.log(key, person[key]);
});

//looping object or to diaply keys and values in object
for (const [key, value] of Object.entries(person)) {
    console.log(key, value);
}

//check key exist in object or not 
if (person.hasOwnProperty("firstname"))

//delete perticular key and value from object
delete person.age;

//create empty object
var person={};

//clear object
person=null;

//to get length of object
var size = Object.keys(person).length;


Array: 
var cars = ["Saab", "Volvo", "BMW"];   //good way
or
var cars = new Array("Saab", "Volvo", "BMW"); //bad way
or
var cars = [{car1:"Saab"}];   //array of objects

//read data from array using idex
cars[0]			o/p saab

//add extra value in array at end of array
cars.push("walk")

//remove last element in array
cars.pop();   

//removes an item from the beginning,
cars.shift()  


//adds element in array from the beginning,
cars.unshift("walk"); 

//delete using inex
delete cars[0];

//update value of first index in array 
cars[0]	= 3;

//get length/size of array
cars.length		o/p 3

//create emty array
cars=[]

//check it is array or not
Array.isArray(cars);	o/p array
or
typeof cars  



array Methods:

foreach():use if you want to loop only, is should not return 

var fruits = ["apple", "orange", "cherry"];

fruits.forEach((value, index, array)=>{
console.log(value)
});

map(): creates a new array with updated values but can not change original values, use if you want to get new array with updated values,

var array= cars.map((value, index, array)=>{
		    return value/10;
		});


every(): use if you want to check, all array values passed condition  then return ture else false

var numbers1 = [45, 4, 9, 16, 25];
var ispassed= numbers1.every((value, index, array)=>{
		   return value>18;				o/p false
		});

some(): use if you want to check, some of array values passed condition then return ture else false


var numbers1 = [45, 4, 9, 16, 25];
var ispassed=numbers1.some((value, index, array)=>{
		   return value>18;				o/p true
		});


indexOf(): when we want to find the index of the first occurrence of a specific value in an array
var a = numbers1.indexOf(16);					o/p 3
arr.lastIndexOf(item, from) – same, but looks for from right to left.
arr.includes(item, from) – looks for item starting from index from, returns true if found.


find(): method returns the value of the first occurrence of a specific value in an array that passes a said condition..

var numbers1 = [45, 4, 9, 16, 25];
var ispassed=numbers1.find((value, index, array)=>{
		   return value>18;				o/p 45
		});

findIndex(): method returns the index of the first occurrence of a specific value in an array that passes a said condition..
var numbers1 = [45, 4, 9, 16, 25];
var ispassed=numbers1.findIndex((total,value, index, array)=>{
		   return value>18;				o/p 0
		});


filter(): creates a new array with filtering data but can not change original values,use if you want to get new array with filter,

var array= cars.filter((value, index, array)=>{
		    return value=="walk";
		});

splice(): method can be used to add new items to an array at specified postions:
var fruits = ["Banana", "Orange", "Apple", "Mango"];	//adding at 2nd position and 0 remval
fruits.splice(2, 0, "Lemon", "Kiwi");			o/p Banana,Orange,Lemon,Kiwi,Apple,Mango
fruits.splice(0, 1);					//remove at position 0 , with 1 remove element

slice(): method slices out a piece of an array into a new array. 
var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];	//1 is start index, 3 is last index but not include last one
var citrus = fruits.slice(1,3);					o/p 1)Banana,Orange,Lemon,Apple,Mango      2) Orange,Lemon
var citrus = fruits.slice(1);					o/p 1)Banana,Orange,Lemon,Apple,Mango      2) Orange,Lemon,Apple,Mango


concat(): method creates a new array by merging (concatenating) existing arrays:
var myGirls = ["Cecilie"];
var myBoys = ["Emil"];
var myChildren = myGirls.concat(myBoys);   		o/p Cecilie,emil

reduce(): use if you want to sum all array values ex: [1,2,3] if you want sum 6 then use reduce.

var numbers1 = [45, 4, 9, 16, 25];
var total= numbers1.reduce((total,value, index, array)=>{
		   return total + value;
		});
The method arr.reduceRight does the same, but goes from right to left.


toString(): convert array to comma saparated string.
join() method also joins all array elements into a string.
var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.join(" * ");

//sort the array
cars.sort((a, b)=>{return a - b});

//reverese the elements in array
cars.reverse();



Different Kinds of Loops:
JavaScript supports different kinds of loops:
foreach - loop arrays values                            
for - loops through a block of code a number of times   
for/in - loops through the properties of an object      
for/of - loops through the values of an iterable object 
while - loops through a block of code while a specified condition is true
do/while - also loops through a block of code while a specified condition is true


examples:
let list = [4, 5, 6];

list.forEach((value, index, array)=>{
console.log(value)
});

for (let i in list) {
   console.log(i); // "0", "1", "2",
}

for (let i of list) {
   console.log(i); // "4", "5", "6"
}

var person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};

for (var key of Object.keys(person)) {
    console.log(key + " -> " + person[key])    
}

for (let key in person) {
  console.log(key);          //object kyes
  console.log(person[key]);  //object values
}

var j=0;
while(j<list.length){
  console.log(list[j]);
  j++;
}

var i = 0;
do {
  console.log(list[i]);
  i++;
} 
while (i<list.length){
  console.log('end');
};



functions:

function sample(x) {
  return x*20;
}
funtion within another funtion:
funtion returns funtion:
funtion pass as param in funtion:

arrow funtions:

hello = () => {
  return "Hello World!";
}
document.getElementById("demo").innerHTML = hello();


// constructor function
function Person () {
    this.name = 'John',
    this.age = 23
}

// creating objects
let person1 = new Person();
let person2 = new Person();

events:

onchange	An HTML element has been changed
onclick		The user clicks an HTML element
onmouseover	The user moves the mouse over an HTML element
onmouseout	The user moves the mouse away from an HTML element
onkeyup		The user up the a keyboard key
onkeydown	The user pushes a keyboard key
onkeypress	The user combination of up and push a keyboard key
onload		The browser has finished loading the page



Date methods:

getFullYear()	Get the year as a four digit number (yyyy)
getMonth()	Get the month as a number (0-11)
getDate()	Get the day as a number (1-31)
getHours()	Get the hour (0-23)
getMinutes()	Get the minute (0-59)
getSeconds()	Get the second (0-59)
getMilliseconds()	Get the millisecond (0-999)
getTime()	Get the time (milliseconds since January 1, 1970)
getDay()	Get the weekday as a number (0-6)
Date.now()	Get the time. ECMAScript 5.

getUTCDate()	Same as getDate(), but returns the UTC date
getUTCDay()	Same as getDay(), but returns the UTC day
getUTCFullYear()	Same as getFullYear(), but returns the UTC year
getUTCHours()	Same as getHours(), but returns the UTC hour
getUTCMilliseconds()	Same as getMilliseconds(), but returns the UTC milliseconds
getUTCMinutes()	Same as getMinutes(), but returns the UTC minutes
getUTCMonth()	Same as getMonth(), but returns the UTC month
getUTCSeconds()	Same as getSeconds(), but returns the UTC seconds

var d = new Date();
var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

document.getElementById("demo").innerHTML = months[d.getMonth()];



Math funtins:

Math.round(4.7);    // returns 5
Math.round(4.4);    // returns 4
Math.random();      // returns a random number


conditions statments:
if
if else
switch

switch (true) {
  case 6:
    text = "Today is Saturday";
    break;
  case 0:
    text = "Today is Sunday";
    break;
  default:
    text = "Looking forward to the Weekend";
}


un-conditions statments:
comments
break
continue


loops:
while
for 
do-while
foreach
for in
for of



exception handling:

try {
  Block of code to try
}
catch(err) {
  Block of code to handle errors
}
finally {
  Block of code to be executed regardless of the try / catch result
}




this:

var person = {
  firstName: "John",
  lastName : "Doe",
  id       : 5566,
  fullName : function() {
    return this.firstName + " " + this.lastName; //this is object person
  }
};

console.log(this); // here this is window object




$(document).ready() 		//method will run once the page DOM is ready to execute JavaScript code.
$(window).load()		//runs only once the entire page is ready (not only DOM).




How to defend against the Persistent XSS attack?

Defending against this attack can be done on the client side or server side.

1.Client-side: The only way to defend this attack in client side is:

Disable JavaScript within the browser
         It may not be a suitable solution as many websites requires it to function appropriately. Therefore, use a safe, secure browser which is of the latest version and with XSS filters turned on. 

 

2.Server-side: Some of the measures to defend in server side are:

Sanitize all user input properly before storing it in the web server.

Sanitize the static content before presenting to the end users.

Use a web vulnerability scanner to detect XSS vulnerability in web applications on a regular basis.



closure:
A closure is a function having access to the parent scope, even after the parent function has closed/returned.
useful to create private variables or functions
var add = (function () {
  var counter = 0;
  return function () {counter += 1; return counter}
})();

add();


or 

function OuterFunction() {

    var outerVariable = 100;

    function InnerFunction() {
        alert(outerVariable);
    }

    return InnerFunction;
}
var innerFunc = OuterFunction();




prototype:
In JavaScript, every function and object has a property named prototype by default
by using this prototype we can add properties and methods to a constructor function.
All JavaScript objects inherit properties and methods from a prototype.

// constructor function
function Person () {
    this.name = 'John',
    this.age = 23
}

// creating objects
let person1 = new Person();
let person2 = new Person();

// adding property to constructor function
Person.prototype.gender = 'male';

// prototype value of Person
console.log(Person.prototype);

// inheriting the property from prototype
console.log(person1.gender);
console.log(person2.gender);

o/p:
{ gender: "male" }
male
male
In the above program, we have added a new property gender to the Person constructor function using:

Person.prototype.gender = 'male';
Then object person1 and person2 inherits the property gender from the prototype property of Person constructor function.



Hoisting: 
it is JavaScript's default behavior of moving all declarations to the top of the current scope